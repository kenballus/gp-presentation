\documentclass[20pt]{extarticle}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[paperwidth=15.11in,paperheight=8.5in, margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{setspace}
\doublespace

\setlength{\topmargin}{0pt}
\setlength{\headsep}{0pt}
\textheight = 900pt

\title{Evolving Programs to Determine Polynomial Ideal Membership}
\author{Ben Kallus and Blake Wintermute}
\date{ }

\begin{document}
\pagecolor{black}
\color{white}
\maketitle

\newpage
\section*{What is a monomial?}

    A monomial consists of a coefficient multiplied by the product of variables raised to non-negative powers.

    Examples: $$x^2,~ 11,~ xyz,~ 5x^4y^7z^2,~ \hdots$$

\newpage
\section*{What is a polynomial?}

    A polynomial is a sum of monomials.

    Examples: $$x^2 + y,~ z,~ xyz + 1 + 22x$$

\newpage
\section*{Principal polynomial ideals.}

    Consider the polynomial $x+1$.
    The ideal generated by $x+1$ is the set of all polynomials that can be expressed as a product of $x+1$ and some other polynomial.
    For instance, $x^2+x$ is in the ideal generated by $x+1$, because $x^2 + x = x(x+1)$.
    We call ideals with one generator principal ideals.

    Let's say we want to figure out whether some polynomial $p$ is in the ideal generated by $x+1$.
    Then, all we have to do is divide $p$ by $x+1$.
    If the remainder is 0 and the quotient is $q$, then $p = q(x+1)$, so $p$ is in the ideal.

\newpage
\section*{Polynomial ideals with multiple generators.}
    Suppose we have two polynomials, $x+1$ and $y-1$.
    We define the ideal generated by $x+1$ and $y-1$ to be the set of all polynomials that can be expressed as the sum of something in the ideal generated by $x+1$ and something in the ideal generated by $y-1$.
    For instance, $x^2+x-y+1$ is in the ideal generated by $x+1$ and $y-1$ because $$x^2+x-y+1 = x(x+1) + -1(y-1).$$
    Note that the ideal generated by $x+1$ and the ideal generated by $y-1$ are each subsets of the ideal generated by $x+1$ and $y-1$.

\newpage
\section*{The problem.}

    How do we determine whether a polynomial $p$ is in the ideal generated by $x+1$ and $y-1$?

\newpage
\section*{A simple algorithm.}

    A simple algorithm for this problem would be to check if $p$ is divisible by any of the generators.
    If it is, then it's in the principal ideal generated by that generator, so it's definitely in the larger ideal.

    However, this strategy doesn't always work.
    Consider the polynomial $1(x+1) + 1(y-1) = x + y$.
    Since $x+y$ is just the sum of the two generators, it's got to be in the ideal.
    However, $x + y$ is not divisible by $x+1$ or $y-1$, so the simple algorithm breaks down.

\newpage
\section*{The true algorithm.}

    Determining polynomial ideal membership is hard.
    The simplest algorithm for solving this problem is to compute a Gr\"obner basis for the ideal, then check if the polynomial is divisible by any of the generators of the Gr\"obner basis.
    Unfortunately, computing Gr\"obner bases is NP-hard, so we evolved programs to determine whether a given polynomial is a member of the ideal generated by a given set of generator polynomials.

% Our Implementation
\newpage
\section*{Polynomial Representation}

We use sorted-maps to represent polynomials. The structure of such a map that would represent $3x^2y^4 + 2x^3$ would be the following in python style syntax:

\begin{verbatim}
{{:x : 2, :y :4} : 3, {:x : 3} : 2}
\end{verbatim}

where we are mapping each term to its coefficient where each term is a mapping from variables to their power.

\subsection*{RevGrevlex}

Specific ordering of monomials in a polynomial that allows systems like polynomial division and L.C.M to be much more efficient.

% Getting into our implementation, the first thing we had to do was to build all the necessary building blocks for working with polynomials. This included all the typical operations: addition, subtraction, multiplication, and division, but also operations like lcm and s-polynomial. Before we could begin to write those, we had to settle on the best way to represent our polynomials using clojure's built in types. There were many suggestions, and unfortunately many changes after we had written some of our operations. We finally decided on relating a map to its coefficient where the key maps relate symbols to their power. Designing our polynomials this way allowed us to do a bunch of optimizations in terms of code complexity. A key function we used was that of the merge-with function which allowed us to combine maps using a specific function when there were keys that exist in both maps. We'll see an example of this in action in a moment. 

% Another element of our polynomial representation worth mentioning is the ordering of the maps. We use a comparison function we're calling REV-grevlex. Requiring this ordering allows for optimizations in the writing of division and lowest common multiplication.
\newpage
\section*{Polynomial Instructions}

Polynomial - \\
\indent addition \\
\indent subtraction     \\   
\indent multiplication \\
\indent division \\
\indent lowest common multiplication \\
\indent s-polynomial \\


\newpage
\section*{Polynomial Add}

\begin{verbatim}

(defn add-polynomials
    [p1 p2]
    (remove-zeros-from-polynomial (merge-with + p1 p2)))

\end{verbatim}

\newpage
\section*{Other Instructions}

\noindent Input- \\
\indent in1 $\rightarrow$ the query polynomial \\
\indent in\_$n$th $\rightarrow$ the $n$\_th element of the generators where $n$ is taken of the integer stack. \\

\noindent Exec- \\
\indent exec-shove $\rightarrow$ Shoves the top element in the exec stack into the $n$th position of the top. \\
\indent exec-yank $\rightarrow$ Yanks the $n$th element from the exec stack and places it on top. \\
\indent exec-dup $\rightarrow$ Duplicates the top element of the exec stack. \\
\indent exec-if $\rightarrow$ If dependent on the integer stack \\
\indent exec-if-zero-polynomial $\rightarrow$ If dependent on if the top polynomial is the 0 polynomial. \\

\newpage
\section*{Error Computation}

\noindent Bounded Logistic flattening

\noindent Programs produce an integer on their integer stack. 

 $$x < -25 \rightarrow 0 $$
 $$x > 25  \rightarrow 1 $$
 $$x \rightarrow \frac{1}{1+e^{-x}}$$

\noindent Smooth confidence predictions, within a bound to prevent endless competition. 

\noindent Positive test cases have a value of 1; negative of 0.

\noindent Error is the summed square of the differences between predicted 

% As the desired output of our programs is an integer, we also saw it prudent to add a number of exec instructions, some of which change the control flow dependent on the state of the polynomial stack. This allows the result of polynomial calculations to impact the overall running of the program and thus the final result. 


\newpage
\section*{Parent Selection}

Lexicase selection

Traditional tournament selection is far to slow


\newpage
\section*{Test Case Generation}

Boutique Python script to produce polynomials. 

Utilizes Macaulay2 to check if randomly generated polynomials are in the Ideal generated by an other random set of polynomials.

Outputs each set of positive and negative test cases via formatting strings to be valid Clojure maps in the form we established earlier.

\newpage
\section*{Experimentation}
\subsection*{No Crossover}

Removing crossover marginally improves the system by arriving at high accuracy individuals at a sooner generation.

\subsection*{Modified Division}

\noindent Original $\rightarrow$ (remainder, quotient, ... rest of polynomial stack)

\noindent Modified $\rightarrow$ (remainder, ... rest of the polynomial stack)

\noindent FAILED TO EVOLVE INDIVIDUALS




\end{document}
