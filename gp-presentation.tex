\documentclass[20pt]{extarticle}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[paperwidth=15.11in,paperheight=8.5in, margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{minted}

\setlength{\topmargin}{0pt}
\setlength{\headsep}{0pt}
\textheight = 900pt

\title{Evolving Programs to Determine Polynomial Ideal Membership}
\author{Ben Kallus and Blake Wintermute}
\date{ }

\begin{document}
\pagecolor{black}
\color{white}
\maketitle

\newpage
\section*{What is a monomial?}

    A monomial consists of a coefficient multiplied by the product of variables raised to non-negative powers.

    Examples: $$x^2,~ 11,~ xyz,~ 5x^4y^7z^2,~ \hdots$$

\newpage
\section*{What is a polynomial?}

    A polynomial is a sum of monomials.

    Examples: $$x^2 + y,~ z,~ xyz + 22x + 1$$

\newpage
\section*{Principal Polynomial Ideals}

    Consider the polynomial $x+1$.
    The ideal generated by $x+1$ is the set of all polynomials that can be expressed as a product of $x+1$ and some other polynomial.
    For instance, $x^2+x$ is in the ideal generated by $x+1$, because $x^2 + x = x(x+1)$.
    Note that 0 must be an element of every ideal.
    We call ideals with one generator principal ideals.

    Let's say we want to figure out whether some polynomial $p$ is in the ideal generated by $x+1$.
    Then, all we have to do is divide $p$ by $x+1$.
    If the remainder is 0, then $p = q(x+1)$ for some polynomial $q$, so $p$ is in the ideal.

\newpage
\section*{Polynomial Ideals with Multiple Generators.}
    Suppose we have two polynomials, $x+1$ and $y-1$.
    We define the ideal generated by $x+1$ and $y-1$ to be the set of all polynomials that can be expressed as the sum of something in the ideal generated by $x+1$ and something in the ideal generated by $y-1$.
    For instance, $x^2+x-y+1$ is in the ideal generated by $x+1$ and $y-1$ because $$x^2+x-y+1 = x(x+1) + -1(y-1).$$
    Note that since 0 is in every ideal, the ideal generated by $x+1$ and the ideal generated by $y-1$ are each subsets of the ideal generated by $x+1$ and $y-1$.

\newpage
\section*{The Problem}

    How do we determine whether a polynomial $p$ is in the ideal generated by $x+1$ and $y-1$?

\newpage
\section*{A Simple Algorithm}

    A simple algorithm for this problem would be to check if $p$ is divisible by any of the generators.
    If it is, then it's in the principal ideal generated by that generator, so it's definitely in the larger ideal.

    However, this strategy doesn't always work.
    Consider the polynomial $1(x+1) + 1(y-1) = x + y$.
    Since $x+y$ is just the sum of the two generators, it's got to be in the ideal.
    However, $x + y$ is not divisible by $x+1$ or $y-1$, so the simple algorithm breaks down.

    Still, you might notice that the remainder after dividing $x+y$ by $x+1$ is $-(y-1)$.
    If we divide that remainder by $y-1$, we get a remainder of 0.
    This is because I chose $x+1$ and $y-1$ in a special way; they form a Gr\"obner basis.

\newpage
\section*{The True Algorithm}

    Determining polynomial ideal membership is hard.
    The simplest algorithm for solving this problem is to compute a Gr\"obner basis for the ideal, then check if the polynomial is divisible by any of the generators of the Gr\"obner basis.
    Unfortunately, computing Gr\"obner bases is NP-hard, so we evolved programs to determine whether a given polynomial is a member of the ideal generated by a given set of generator polynomials.

% Our Implementation
\newpage
\section*{Polynomial Representation}

We use sorted-maps to represent polynomials. The structure of the map that would represent $3x^2y^4 + 2x^3$ would be the following:

\begin{verbatim}
{{:x : 2, :y :4} 3, {:x 3} 2}.
\end{verbatim}

In other words, we're mapping each term to its coefficient where each term is a mapping from variables to their power.

\subsection*{Grevlex}

Specific monomial ordering that can improve performance for polynomial division and L.C.M.
Computer algebra systems usually use this ordering for dealing with polynomials ideals.

% Getting into our implementation, the first thing we had to do was to build all the necessary building blocks for working with polynomials. This included all the typical operations: addition, subtraction, multiplication, and division, but also operations like lcm and s-polynomial. Before we could begin to write those, we had to settle on the best way to represent our polynomials using clojure's built in types. There were many suggestions, and unfortunately many changes after we had written some of our operations. We finally decided on relating a map to its coefficient where the key maps relate symbols to their power. Designing our polynomials this way allowed us to do a bunch of optimizations in terms of code complexity. A key function we used was that of the merge-with function which allowed us to combine maps using a specific function when there were keys that exist in both maps. We'll see an example of this in action in a moment. 

% Another element of our polynomial representation worth mentioning is the ordering of the maps. We use a comparison function we're calling REV-grevlex. Requiring this ordering allows for optimizations in the writing of division and lowest common multiplication.
\newpage
\section*{Polynomial Instructions}

Polynomial - \\
\indent addition \\
\indent subtraction     \\   
\indent multiplication \\
\indent division \\
\indent s-polynomial \\


\newpage
\section*{Polynomial Addition}
\begin{minted}{clojure}
(defn add-polynomials
    [p1 p2]
    (merge-with + p1 p2))
\end{minted}

\newpage
\section*{Polynomial Division}
{\tiny
\begin{minted}{clojure}
(defn divide-monomials
  [p1 p2]
  (let [t1 (first (keys p1))
        c1 (first (vals p1))
        t2 (first (keys p2))
        c2 (first (vals p2))]
    (cond (or (= c1 0) (= c2 0))
            (list zero-polynomial
                  (sorted-map-by revgrevlex t1 c1))
          (monomials-are-divisible p1 p2)
            (list (sorted-map-by revgrevlex
                                 (into (sorted-map)
                                       (filter (fn [[var pow]] (not= pow 0))
                                               (merge-with -' t1 t2)))
                                 (/ c1 c2))
                  zero-polynomial)
          :else
            (list zero-polynomial
                  (sorted-map-by revgrevlex t1 c1)))))

(defn divide-polynomials
  [p1 p2]
    (map remove-zeros-from-polynomial
      (loop [curr p1
             q-result zero-polynomial
             r-result zero-polynomial]
        (if (= curr zero-polynomial)
          (list q-result r-result)
          (let [[q-curr r-curr] (divide-monomials curr p2)]
            (if (= r-curr zero-polynomial)
              (recur (subtract-polynomials curr (multiply-polynomials p2 q-curr))
                     (add-polynomials q-result q-curr)
                     r-result)
              (recur (subtract-polynomials curr (leading-term curr))
                     q-result
                     (add-polynomials r-result r-curr))))))))
\end{minted}
}

\newpage
\section*{Other Instructions}

\noindent Input- \\
\indent in1 $\rightarrow$ Puts the query polynomial on the top of the exec stack. \\
\indent in\_$n$th $\rightarrow$ Puts the $n$\textsuperscript{th} element of the generators on the top of the exec stack. ($n$ is taken off the integer stack) \\

\noindent Exec- \\
\indent exec-shove $\rightarrow$ Shoves the top element in the exec stack into the $n$th position from the top. \\
\indent exec-yank $\rightarrow$ Moves the $n$\textsuperscript{th} element of the exec stack to the top. \\
\indent exec-dup $\rightarrow$ Duplicates the top element of the exec stack. \\
\indent exec-if $\rightarrow$ If dependent on the sign of the top integer. \\
\indent exec-if-zero-polynomial $\rightarrow$ If dependent on whether the top polynomial is the 0 polynomial. \\

\newpage
\section*{Error Computation}

\noindent Bounded Logistic flattening

\noindent Programs produce an integer on their integer stack. 

 $$x < -25 \rightarrow 0 $$
 $$x > 25  \rightarrow 1 $$
 $$x \rightarrow \frac{1}{1+e^{-x}}$$

\noindent Smooth confidence predictions, within a bound to prevent endless competition. 

\noindent Positive test cases have a value of 1; negative of 0.

\noindent Error is the sum of the squares of the differences between the program output and the correct answer.

% As the desired output of our programs is an integer, we also saw it prudent to add a number of exec instructions, some of which change the control flow dependent on the state of the polynomial stack. This allows the result of polynomial calculations to impact the overall running of the program and thus the final result. 

\newpage
\section*{Parent Selection}

Lexicase selection

Traditional tournament selection is too slow.

Traditional lexicase selection is also too slow. 

We subsample 50 test cases and 50 individuals to improve running time.

\newpage
\section*{Test Case Generation}

We used a Python script to create a random polynomial and a random polynomial ideal.
Then, we check whether the polynomial is an element of the ideal using the computer algebra system Macaulay2.
We generate an equal number of positive and negative test cases.
Since it's easier to generate negative test cases, this can take a long time.

Our first set of test cases used up to 3 variables, up to 3 monic terms per polynomial, a maximum exponent of 3, and up to 5 generators per ideal.
Our second set of test cases used up to 3 variables, up to 5 terms with coefficients between -5 and 5 per polynomial, a maximum exponent of 5, up to 5 generators per ideal.

\newpage
\section*{Experimentation}
\subsection*{No Crossover}

Removing crossover did not significantly improve the system.

Did improve running time for each generation as the number of lexicase selections was reduced. 

Did not arrive at a high accuracy individual significantly sooner.

\subsection*{Modified Division}

\noindent Original $\rightarrow$ (remainder, quotient, ... rest of polynomial stack)

\noindent Modified $\rightarrow$ (remainder, ... rest of the polynomial stack)

\noindent \textbf{FAILED TO EVOLVE INDIVIDUALS!}


\newpage
\section*{Conclusion}

Substantial more research to be done on this problem, especially given this proof of concept.

Not replicating Buchberger's Algorithm $\rightarrow$ Something interesting.
\end{document}


% To do:
% conclusion
% include some code
% 