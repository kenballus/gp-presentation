\documentclass[20pt]{extarticle}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[paperwidth=15.11in,paperheight=8.5in, margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{setspace}
\doublespace

\setlength{\topmargin}{0pt}
\setlength{\headsep}{0pt}
\textheight = 900pt

\title{Evolving Programs to Determine Polynomial Ideal Membership}
\author{Ben Kallus and Blake Wintermute}
\date{ }

\begin{document}
\pagecolor{black}
\color{white}
\maketitle

\newpage
\section*{What is a monomial?}

    A monomial consists of a coefficient multiplied by the product of variables raised to non-negative powers.

    Examples: $$x^2,~ 11,~ xyz,~ 5x^4y^7z^2,~ \hdots$$

\newpage
\section*{What is a polynomial?}

    A polynomial is a sum of monomials.

    Examples: $$x^2 + y,~ z,~ xyz + 1 + 22x$$

\newpage
\section*{What is a polynomial ideal?}

    Consider the polynomial $x+1$.
    The ideal generated by $x+1$ is the set of all polynomials that can be written as a product of $x+1$ and some other polynomial.
    For instance, $x^2+x$ is in the ideal generated by $x+1$, because $x^2 + x = x(x+1)$.

    Suppose we have another polynomial, $x-1$.
    We define the ideal generated by $x+1$ and $x-1$ to be the set of all polynomials that can be written as the sum of something in the ideal generated by $x+1$ and something in the ideal generated by $x-1$.
    For instance, $x^2 + 1$ is in the ideal generated by $x+1$ and $x-1$ because $$x^2+1 = x(x+1) + -1(x-1).$$

\newpage
\section*{The problem.}

    How do we determine whether the polynomial $xy + x$ is in the ideal generated by $x+1$ and $x-1$?

\newpage
\section*{A simple algorithm.}

    A simple algorithm for this problem would be to check if $xy+x$ is divisible by any of the generators.
    If it is, then it's definitely in the ideal.
    That works in this case; $xy + x$ is divisible by $y+1$, so it must be in the ideal.

    However, this strategy doesn't always work.
    Consider the polynomial $1(x+1) + 1(y-1) = x + y$.
    Since $x+y$ is just the sum of the two generators, it's got to be in the ideal.
    However, $x + y$ is not divisible by $x+1$ or $y-1$, so the simple algorithm breaks down.

\newpage
\section*{The true algorithm.}

    Determining polynomial ideal membership is hard.
    The simplest algorithm for solving this problem is to compute a Gr\"obner basis for the ideal, then check if the polynomial is divisible by any of the generators of the Gr\"obner basis.
    Unfortunately, computing Gr\"obner bases is NP-hard, so we evolved programs to determine whether a given polynomial is a member of the ideal generated by a given set of generator polynomials.


% Our Implementation}
\newpage
\section*{Polynomial Representation}

We use sorted-maps to represent polynomials. The structure of such a map that would represent $3x^2y^4 + 2x^3$ would be the following in python style syntax:

\begin{verbatim}
poly = {{:x : 2, :y :4} : 3, {:x : 3} : 2}
\end{verbatim}

 where we are maping each term to its coefficent where each term is a mapping from variables to their power.

\newpage
\section*{Polynomial Instructions}

Polynomial - \\
\indent addition \\
\indent subtraction     \\   
\indent multiplicationA \\
\indent division \\
\indent lowest common multiplication \\
\indent s-polynomial \\

\newpage
\section*{Other Instructions}

\noindent Input- \\
\indent in1 $\rightarrow$ the query polynomial \\
\indent in\_$n$th $\rightarrow$ the $n$\_th element of the generators where $n$ is taken of the integer stack. \\

\noindent Exec- \\
\indent exec-shove $\rightarrow$ Shoves the top element in the exec stack into the $n$th position of the top. \\
\indent exec-yank $\rightarrow$ Yanks the $n$th element from the exec stack and places it on top. \\
\indent exec-dup $\rightarrow$ Duplicates the top element of the exec stack. \\
\indent exec-if $\rightarrow$ If dependent on the integer stack \\
\indent exec-if-zero-polynomial $\rightarrow$ If dependent on if the top polynomial is the 0 polynomial. \\

% Getting into our implementation, the first thing we had to do was to build all the necessary building blocks for working with polynomials. This included all the typical operations: addition, subtraction, multiplication, and division, but also operations like lcm and s-polynomial. Before we could begin to write those, we had to settle on the best way to represent our polynomials using clojure's built in types. There were many suggestions, and unfortunately many changes after we had written some of our operations. We finally decided on relating a map to its coefficient where the key maps relate symbols to their power. Designing our polynomials this way allowed us to do a bunch of optimizations in terms of code complexity. A key function we used was that of the merge-with function which allowed us to combine maps using a specific function when there were keys that exist in both maps. With this function, operations like polynomial addition are as simple as (merge-with + p1 p2) 

% 

% As the desired output of our programs is an integer, we also saw it prudent to add a number of exec instructions, some of which change the control flow dependent on the state of the polynomial stack. This allows the result of polynomial calculations to impact the overall running of the program and thus the final result. 

\newpage
\section*{Error Computation}

\noindent Bounded Logistic flattening

\noindent Programs produce an integer on their integer stack. 

 $$x < -25 \rightarrow 0 $$
 $$x > 25  \rightarrow 1 $$
 $$\rightarrow \frac{1}{1+e^{-x}}$$

Smooth confidence predictions, within a bound to prevent endless competition. 

Positive test cases have a value of 1; negative of 0.

Error is the summed square of the differences between predicted 
\newpage
\section*{Test Case Generation}

Boutique python script to produce polynomials. 

Utilizes Macaulay2 to, while generating random polynomials, to check if that polynomial is in the Ideal generated by a random set of polynomials.

\newpage
\section*{Experimentation with Crossover}

Removing crossover marginally improves the system by arriving at high accuracy individuals at a sooner generation.

\newpage
\section*{Experimentation with Modified Division}

Original $\rightarrow$ (remainder, quotient, ... rest of polynomial stack)

Modified $\rightarrow$ (remainder, ... rest of the polynomial stack)

FAILED


\end{document}
